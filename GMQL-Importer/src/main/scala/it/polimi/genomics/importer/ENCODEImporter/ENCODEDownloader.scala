package it.polimi.genomics.importer.ENCODEImporter

import java.io.File
import java.net.URL

import it.polimi.genomics.importer.GMQLImporter.{GMQLDownloader,GMQLSource,GMQLDataset}
import it.polimi.genomics.importer.FileLogger.FileLogger

import scala.sys.process._
import scala.io.Source

/**
  * Created by Nacho on 10/13/16.
  */
object ENCODEDownloader extends GMQLDownloader{
  /**
    * downloads the files from the source defined in the loader
    * into the folder defined in the loader
    * recursively checks all folders and subfolders matching with the regular expressions defined in the loader
    * @param source contains specific download and sorting info.
    */
  override def download(source: GMQLSource): Unit = {
    println("Starting download for: "+source.outputFolder)
    if (!new java.io.File(source.outputFolder).exists) {
      new java.io.File(source.outputFolder).mkdirs()
    }
    downloadIndexAndMeta(source)
  }

  /**
    * For ENCODE given the parameters, a link for downloading metadata and
    * file index is generated, here, that file is downloaded and then, for everyone
    * downloads all the files linked by it.
    * @param source information needed for downloading ENCODE datasets.
    */
  private def downloadIndexAndMeta(source: GMQLSource): Unit ={
    source.datasets.foreach(dataset =>{
      val outputPath = source.outputFolder + "/" + dataset.outputFolder +"/Downloads"
      if (!new java.io.File(outputPath).exists) {
        new java.io.File(outputPath).mkdirs()
      }
      val indexAndMetaUrl = generateDownloadIndexAndMetaUrl(source,dataset)
      //here I should log the .meta file with FileLogger but I dont know how to know the
      //parameters needed prior to download the file. also, this file should always be downloaded,
      //so there is no need of checking it, ENCODE always provide the last version of this .meta file.
      if(urlExists(indexAndMetaUrl)){
        downloadFileFromURL(
          indexAndMetaUrl,
          source.outputFolder+"/"+dataset.outputFolder+"/Downloads/"+dataset.outputFolder+".tsv")
        downloadFilesFromMetadataFile(source,dataset)
        println("download for "+dataset.outputFolder+" completed")
      }
      else {
        println("download link generated by " + dataset.outputFolder + " does not exist")
        println("download link:"+indexAndMetaUrl)
      }
    })
  }

  /**
    * generates download link for the metadata file
    * @param source contains information related for connecting to ENCODE
    * @param dataset contains information for parameters of the url
    * @return full url to download metadata file from encode.
    */
  def generateDownloadIndexAndMetaUrl(source: GMQLSource, dataset: GMQLDataset):String={
    source.url + generateParameterSet(dataset) + source.parameters.filter(_._1 == "metadata_suffix").head._2
  }

  /**
    * concatenates all the folder's parameters with & in between them
    * and = inside them
    * @param dataset contains all the parameters information
    * @return string with parameter=value & ....
    */
  private def generateParameterSet(dataset: GMQLDataset): String ={
    var set = ""
    dataset.parameters.foreach(parameter =>{
      set = set + parameter._1 + "=" + parameter._2 + "&"
    })
    if(set.endsWith("&"))
      set.substring(0,set.length-1)
    else
      set
  }
  /**
    * given a url and destination path, downloads that file into the path
    * @param url source file url.
    * @param path destination file path and name.
    */
  def downloadFileFromURL(url:String,path:String): Unit ={
    print("Downloading: " + path + " from: " + url)
    //I have to recheck if this is safe
    new URL(url) #> new File(path) !!;
    println(" DONE")
  }

  /**
    * explores the downloaded metadata file with all the urls directing to the files to download,
    * checks if the files have to be updated, downloaded, deleted and performs the actions needed.
    * puts all downloaded files into /information.outputFolder/folder.outputFolder/Downloads
    *
    * @param source contains information for ENCODE download.
    * @param dataset dataset specific information about its location.
    */
  private def downloadFilesFromMetadataFile(source: GMQLSource, dataset: GMQLDataset): Unit = {
    //attributes that im looking into the line:
    //Experiment date released (22), Size (36), md5sum (38), File download URL(39)
    //maybe this parameters should be entered by xml file
    val header = Source.fromFile(
      source.outputFolder + "/" +
        dataset.outputFolder + "/Downloads/" +
        dataset.outputFolder + ".tsv").getLines().next().split("\t")

    val originLastUpdate = header.lastIndexOf("Experiment date released")
    val originSize = header.lastIndexOf("Size")
    //to be used
    //val md5sum = header.lastIndexOf("md5sum")
    val url = header.lastIndexOf("File download URL")

    val log = new FileLogger(source.outputFolder + "/" + dataset.outputFolder + "/Downloads")
    /*I will check all the server files against the local ones so i mark as to compare,
    * the files will change their state while I check each one of them. If there is
    * a file deleted from the server will be marked as OUTDATED before saving the table back*/
    log.markToCompare()
    Source.fromFile(
      source.outputFolder + "/" +
        dataset.outputFolder + "/Downloads/" +
        dataset.outputFolder + ".tsv").getLines().drop(1).foreach(line => {
      val fields = line.split("\t")
      val filename = fields(url).split("/").last
      if (urlExists(fields(url))) {
        if (log.checkIfUpdate(filename, fields(url), fields(originSize), fields(originLastUpdate))) {
          //MUST BE DONE: handle if the file is not downloaded.
          //if not downloaded use log.markAsFailed(filename)
          downloadFileFromURL(fields(url), source.outputFolder + "/" + dataset.outputFolder + "/Downloads/" + filename)
          log.markAsUpdated(filename)
        }
      }
      else
        println("could not download " + filename + " from " + dataset.outputFolder)
    })
    log.markAsOutdated()
    log.saveTable()
  }
  /**
    * checks if the given URL exists
    * @param path URL to check
    * @return URL exists
    */
  def urlExists(path: String): Boolean = {
    try {
      scala.io.Source.fromURL(path)
      true
    } catch {
      case _: Throwable => false
    }
  }
}
